# Concepts

## Introduction

NAMOS comes with a few different concepts, which comes with their own primitives.
This document will try to summarize them and, something that wasn't on the paper
but could be helpful for future implementers, Haskell-style type annotations.

This document also lists the page number where each primitive has been defined
in the [original paper][1] which makes our lifes way easier... 

## Version Reference

### Freeze (p. 56)

```haskell
freeze :: objectReference -> pseudoTime -> versionReference
```

This is a function that generates a version reference from an object reference and a pseudo-time.


### Define  (p. 57)

```haskell
data DefineException =
     NonExistentState
   | Redefinition

define :: (MonadThrow m, Eq versionReference) => versionReference -> value -> m Define'sResult
```

This operation creates the version specified by the version reference. It is used by the desugaring of an update operation on an object. The second parameter is a value that will be the value of the version referred to by the version reference, if no error is signalled. The nonexistent state error indicates that an attempt to assign a version that never will exist (no version of the object exist for that pseudo-time). The redefinition error indicates that there was already a valid version associated with the specified version reference. The version_ref/define operation can be applied at most once to a version reference.

### Lookup  (p. 57)

version_ref/lookup(vr)
signals(nonexistent state) # => value
This operation gets the version associated with a particular version reference. It is used in the desugaring of an operation that reads the value of an object. The nonexistent state error indicates that the version reference specifies a state that will never have existed.


### Decompose (p. 57)

version_ref/decompose(vr) # => or, pt
This operation is just the inverse of version_ref/freeze



## ObjectReference

### Eq (p. 56)

```haskell
eq :: ObjectReference -> ObjectReference -> Bool
```

This is a function that tells if two object references refer to the same object.  NAMOS does not refer
to any actual implementation and `eq` should be seen as strict comparison between immutable data structures.
The paper still mentions CLU and LISP's `eq` function though.


### Create (p. 58)

object_ref/create(pt) # => or
This operation creates an object reference whose t-sub-create is specified by the parameter


# Delete (p. 58)

object_ref/delete(or, pt) 
signals(bad delete)

This operation deletes the object speicfied by the first parameter, by setting the deletion pseudo-time to
the second parameter.  The signal `bad delete` indicates the delete operation was not performed because the
specified pseudo-time was inconsistent with the history of the object.  This could be because the pseudo-time
preceeded the creation pseudo-time or because a version corresponding to that pseudo-time exists or because
the delete pseudo-tme has already been set to another value.  As in the version_ref/define operation, only one
such operation may ever be applied to the particular object reference.


## Pseudo-Time

### Transaction (p. 64)

pte/transaction(pte1) # => pte2
The pseudo-temporal environment pte2 is a subrange of pte1.  It is guaranteed that the result of two separate
invocations of the pte/transaction on the same pte will be two ptes x and y such that x ~> y or y ~> x. 
That is, x and y are non-overlapping subranges.  Further, after executing w := pte/transaction(z), w is a subset
of z.  pte/transaction can be applied repeatedly, in order to generate subranges of subranges.


### Current (p. 64)

pte/current(pte) # => pt (pseudo-time)
If X is the set of pseudo-times returned by pte/next(y) operations or contained in pte generated by
pte/transaction(y) operations executed before a := pte/current(y) is executed, then for all x in X, x => a


### Next (p. 65)

pte/next(pte) # => pt
If X is the set of pseudo-times returned by pte/next(y) operations or contained in pseudo-temporal environments
generated by pte/transaction(y) operations executed before a := pte/next(y), then for all x in X, a ~> x



## Examples

```haskell
vref1 = freeze(objref1, ptime)
vref2 = freeze(objref2, ptime)
vref3 = freeze(objref3, ptime)

value1 <- lookup vref1
value2 <- lookup vref2
value3 <- lookup vref3

sum <- foldl (+) 0 [value1, value2, value3]
```

[1]: http://publications.csail.mit.edu/lcs/pubs/pdf/MIT-LCS-TR-205.pdf
