# Concepts

## Introduction

NAMOS comes with a few different concepts, which comes with their own primitives.
This document will try to summarize them and, something that wasn't on the paper
but could be helpful for future implementers, Haskell-style type annotations.

## Version Reference

### Freeze

```haskell
freeze :: ObjectReference -> Pseudo-Time -> Version Reference
```

This is a function that generates a version reference from an object reference and a pseudo-time.


### Define

version_ref/define(vr, value) 
signals(nonexistent state, redefinition)
This operation creates the version specified by the version reference. It is used by the desugaring of an update operation on an object. The second parameter is a value that will be the value of the version referred to by the version reference, if no error is signalled. The nonexistent state error indicates that an attempt to assign a version that never will exist (no version of the object exist for that pseudo-time). The redefinition error indicates that there was already a valid version associated with the specified version reference. The version_ref/define operation can be applied at most once to a version reference.

### Lookup

version_ref/lookup(vr) 
signals(nonexistent state) # => value
This operation gets the version associated with a particular version reference. It is used in the desugaring of an operation that reads the value of an object. The nonexistent state error indicates that the version reference specifies a state that will never have existed.


### Decompose

version_ref/decompose(vr) # => or, pt
This operation is just the inverse of version_ref/freeze



## ObjectReference

### Eq

```haskell
eq :: ObjectReference -> ObjectReference -> Bool
```

This is a function that tells if two object references refer to the same object.  NAMOS does not refer
to any actual implementation and `eq` should be seen as strict comparison between immutable data structures.


### Create

object_ref/create(pt) # => or
This operation creates an object reference whose t-sub-create is specified by the parameter


# Delete

object_ref/delete(or, pt) 
signals(bad delete)

This operation deletes the object speicfied by the first parameter, by setting the deletion pseudo-time to
the second parameter.  The signal `bad delete` indicates the delete operation was not performed because the
specified pseudo-time was inconsistent with the history of the object.  This could be because the pseudo-time
preceeded the creation pseudo-time or because a version corresponding to that pseudo-time exists or because
the delete pseudo-tme has already been set to another value.  As in the version_ref/define operation, only one
such operation may ever be applied to the particular object reference.


## Pseudo-Time

### Transaction

pte/transaction(pte1) # => pte2
The pseudo-temporal environment pte2 is a subrange of pte1.  It is guaranteed that the result of two separate
invocations of the pte/transaction on the same pte will be two ptes x and y such that x ~> y or y ~> x. 
That is, x and y are non-overlapping subranges.  Further, after executing w := pte/transaction(z), w is a subset
of z.  pte/transaction can be applied repeatedly, in order to generate subranges of subranges.


### Current

pte/current(pte) # => pt (pseudo-time)
If X is the set of pseudo-times returned by pte/next(y) operations or contained in pte generated by
pte/transaction(y) operations executed before a := pte/current(y) is executed, then for all x in X, x => a


### Next

pte/next(pte) # => pt
If X is the set of pseudo-times returned by pte/next(y) operations or contained in pseudo-temporal environments
generated by pte/transaction(y) operations executed before a := pte/next(y), then for all x in X, a ~> x



## Examples

```haskell
vref1 = freeze(objref1, ptime)
vref2 = freeze(objref2, ptime)
vref3 = freeze(objref3, ptime)

value1 <- lookup vref1
value2 <- lookup vref2
value3 <- lookup vref3

sum <- foldl (+) 0 [value1, value2, value3]
```
